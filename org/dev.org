#+title: helpers.py

#+begin_src org
  This is a meta file from which are generated source files.
#+end_src

* org
* py
** header
*** shebang

#+name: py-shebang
#+begin_src python
  #!/usr/bin/env python
#+end_src

*** license

#+name: py-license
#+begin_src python
  # -----------------------------------------------------------------
  # Copyright (C) 2025 Erwann Rogard
  # Source repository: https://github.com/rogard/helpers.py
  #
  # Python code:
  # Released under the GNU General Public License v3.0 or later
  # See https://www.gnu.org/licenses/gpl-3.0.html
  # -----------------------------------------------------------------
#+end_src

*** encoding

#+name: py-encoding
#+begin_src python
  # A reminder that this is legacy code
  # -*- coding: utf-8 -*-
#+end_src

** censor
:PROPERTIES:
:header-args: :tangle "../py/censor.py"
:END:

#+header: :noweb yes
#+begin_src python
  <<py-shebang>>
#+end_src

#+header: :noweb yes
#+begin_src python
  <<py-license>>
#+end_src

#+begin_src python
  import os
  import re
  import sys
#+end_src

#+begin_src python
  UNSAFE_INFIX = ".unsafe"
#+end_src

#+begin_src python
  DEFAULT_COMMENT_SYMBOLS = {
      "py": "#",
      "python": "#",
      "js": "//",
      "javascript": "//",
      "ts": "//",
      "cpp": "//",
      "c": "//",
      "h": "//",
      "java": "//",
      "rb": "#",
      "sh": "#",
      "bash": "#",
      "tex": "%",
      "txt": "#",
      "md": "<!--",
  }
#+end_src

#+begin_src python
  def guess_comment_symbol(language: str) -> str:
      """Return the default comment symbol for a given language."""
      return DEFAULT_COMMENT_SYMBOLS.get(language.lower(), "#")
#+end_src

#+begin_src python
  # Default infix for unsafe files
  UNSAFE_INFIX = ".unsafe"
#+end_src

#+begin_src python
  CENSOR_BEGIN_ANCHOR_TEMPLATE = "{comment} <censor>"
  CENSOR_END_ANCHOR_TEMPLATE = "{comment} </censor>"
#+end_src

#+begin_src python
  DEFAULT_COMMENT_SYMBOLS = {
      "py": "#",
      "python": "#",
      "js": "//",
      "javascript": "//",
      "ts": "//",
      "cpp": "//",
      "c": "//",
      "h": "//",
      "java": "//",
      "rb": "#",
      "sh": "#",
      "bash": "#",
      "tex": "%",
      "txt": "#",
      "md": "<!--",
  }
#+end_src

#+begin_src python
  def guess_comment_symbol(language: str) -> str:
      return DEFAULT_COMMENT_SYMBOLS.get(language.lower(), "#")
#+end_src

#+begin_src python
  def infer_output_path(input_path: str, strip_infix: str) -> str:
      """
      Strip the first occurrence of `infix` from the filename.
      Raise ValueError if `infix` is not found.
      """
      base, ext = os.path.splitext(input_path)
      if infix not in base:
          raise ValueError(f"Input file '{input_path}' does not contain the required infix '{infix}'")
      cleaned_base = base.replace(infix, "", 1)
      return cleaned_base + ext
#+end_src

#+begin_src python
  def process_file(*, input_path, output_path=None, language=None,
                   comment_symbol=None, search_begin=None,
                   search_end=None, replace_fn=None, infix=UNSAFE_INFIX):
      """
      Process a file by replacing text between <censor> anchors.
      All parameters are keyword-only.

      output_path:
          - None: auto-infer from input_path by removing `infix`
          - "-": print to stdout
          - sys.stdout: print to stdout
          - string: path to output file
      """
      # Compute output_path if not provided
      if output_path is None:
          output_path = infer_output_path(input_path, infix=infix)

      # Compute language from extension
      if language is None:
          ext = os.path.splitext(input_path)[1].lstrip(".")
          language = ext or "txt"

      # Compute comment_symbol
      if comment_symbol is None:
          comment_symbol = guess_comment_symbol(language)

      # Compute search anchors
      if search_begin is None:
          search_begin = CENSOR_BEGIN_ANCHOR_TEMPLATE.format(comment=comment_symbol)
          
      if search_end is None:
          search_end = CENSOR_END_ANCHOR_TEMPLATE.format(comment=comment_symbol)

      # Default replacement function
      if replace_fn is None:
          replace_fn = lambda: f"{comment_symbol} CENSORED"

      # Build regex pattern (non-greedy)
      pattern = re.compile(
          re.escape(search_begin) + r"(.*?)" + re.escape(search_end),
          flags=re.DOTALL
      )

      # Read input
      with open(input_path, "r", encoding="utf-8") as f:
          text = f.read()

      # Replace censored blocks
      new_text = pattern.sub(lambda m: replace_fn(), text)

      # Write output
      if output_path == "-" or output_path is sys.stdout:
          print(new_text, end="")
          print(f"\n[INFO] Sanitized content printed to stdout.", file=sys.stderr)
      else:
          with open(output_path, "w", encoding="utf-8") as f:
              f.write(new_text)
              print(f"Sanitized file written to: {output_path}")
#+end_src

#+begin_src python
  if __name__ == "__main__":
      import argparse
      import sys

      parser = argparse.ArgumentParser(description="Sanitize a file by replacing <censor> blocks.")
      parser.add_argument("input_path", help="Path to the input file")
      parser.add_argument("-o", "--output_path", help="Output file path (use '-' for stdout)", default=None)
      parser.add_argument("-l", "--language", help="Language for comment symbol inference", default=None)
      parser.add_argument("-c", "--comment_symbol", help="Override comment symbol", default=None)
      parser.add_argument("--search_begin", help="Override <censor> begin anchor", default=None)
      parser.add_argument("--search_end", help="Override <censor> end anchor", default=None)
      parser.add_argument("--infix", help="Infix marking unsafe file", default=UNSAFE_INFIX)

      args = parser.parse_args()

      # call the function
      process_file(
          input_path=args.input_path,
          output_path=args.output_path,
          language=args.language,
          comment_symbol=args.comment_symbol,
          search_begin=args.search_begin,
          search_end=args.search_end,
          infix=args.infix
      )
#+end_src

** ical2json
:PROPERTIES:
:header-args: :tangle "../py/ical2json.py"
:END:

This is a modified COPY of @philippbosch's [[https://github.com/philippbosch/ical2json/blob/master/LICENSE][script ical2censor]].

#+begin_src python
  #!/usr/bin/env python
  # -*- coding: utf-8 -*-
#+end_src

#+begin_src python
  # Original code (Bosch) as recorded at:
  # https://github.com/rogard/helpers.py, commit 9d1a659
  # Exception handling modified thereafter
#+end_src

#+begin_src python
  #  Copyright (c) 2011, Philipp Bosch
  #
  #  Permission is hereby granted, free of charge, to any person obtaining a
  #  copy of this software and associated documentation files (the Software),
  #  to deal in the Software without restriction, including
  #  without limitation the rights to use, copy, modify, merge, publish,
  #  distribute, sublicense, and/or sell copies of the Software, and to
  #  permit persons to whom the Software is furnished to do so, subject to
  #  the following conditions:
  #
  #  The above copyright notice and this permission notice shall be included
  #  in all copies or substantial portions of the Software.
  #
  #  THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS
  #  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  #  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  #  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  #  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  #  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  #  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#+end_src

#+header: :noweb yes
#+begin_src python
  <<py-license>>
#+end_src

#+begin_src python
  import os

  from flask import Flask, abort, jsonify, request
  from icalendar import Calendar
  import requests

  app = Flask(__name__)
#+end_src

#+begin_src python
  @app.route('/')
  def index():
      return u'Please use like <code>http://<script>document.write(location.host);</script><noscript>ical2json.pb.io</noscript>/http://www.myserver.com/path/to/file.ics</code><br>Source code and instructions at <a href="http://github.com/philippbosch/ical2json">http://github.com/philippbosch/ical2json</a>.'
#+end_src

#+begin_src python
  @app.route('/<path:url>')
  def convert_from_url(url):
      if url == 'favicon.ico':
          abort(404)
      if not url.startswith('http'):
          url = 'http://%s' % url

      try:
          r = requests.get(url)
          r.raise_for_status()
          
          # previous attempt:
          # try:
          #     r = requests.get(url)
          # except:
          #     abort(500)
          # if not r.ok:
          #     abort(r.status_code)
          
          ics = r.content
          cal = Calendar.from_ical(ics)
      except requests.HTTPError as e:
          # Source URL returned an error
          abort(e.response.status_code if 400 <= e.response.status_code < 600 else 500)
      except requests.RequestException:
          abort(502)  # Bad Gateway - couldn't reach source
      except Exception:
          abort(500)  # Internal error parsing ICS

      # build data
      data = {}
      data[cal.name] = dict(cal.items())

      for component in cal.subcomponents:
          if not component.name in data[cal.name]:
              data[cal.name][component.name] = []

          comp_obj = {}
          for item in component.items():
              if hasattr(item[1], 'dt'):
                  val = item[1].dt.isoformat()
              else:
                  val = item[1].to_ical().decode('utf-8').replace('\\,', ',')
                  comp_obj[item[0]] = val

          data[cal.name][component.name].append(comp_obj)

      resp = jsonify(data)
      if 'callback' in request.args:
          resp.data = "%s(%s);" % (request.args['callback'], resp.data)
      return resp
#+end_src

#+begin_src python
  if __name__ == '__main__':
      port = int(os.environ.get('PORT', 5000))
      app.run(host='0.0.0.0', port=port, debug=True)  
#+end_src

#+begin_src python
  if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=False, use_reloader=False)
#+end_src

** ics2json
:PROPERTIES:
:header-args: :tangle "../py/ics2json.py"
:END:

#+header: :noweb yes
#+begin_src python
  <<py-shebang>>
#+end_src

#+header: :noweb yes
#+begin_src python
  <<py-license>>
#+end_src

#+begin_src python
  """
  Convert ICS calendar files to JSON format.
  Fetches from URLs or reads local files.
  """
  import argparse
  import json
  import sys
  from pathlib import Path
  from icalendar import Calendar
  import requests
#+end_src

#+begin_src python
  # Constants
  DEFAULT_TIMEOUT = 30
  DEFAULT_TEMP_SUFFIX = '.ics'
  DEFAULT_TEMP_PREFIX = 'ics2json_'
  DEFAULT_JSON_INDENT = 2
#+end_src

#+begin_src python
  def ics_to_dict(ics_content):
      """
      Convert ICS content to dictionary.
      
      Args:
          ics_content: Bytes or string containing ICS data
          
      Returns:
          Dictionary with calendar data
      """
      if isinstance(ics_content, str):
          ics_content = ics_content.encode('utf-8')
          
      cal = Calendar.from_ical(ics_content)
      
      # Build data structure
      data = {}
      data[cal.name] = dict(cal.items())
      
      for component in cal.subcomponents:
          if component.name not in data[cal.name]:
              data[cal.name][component.name] = []
              
          comp_obj = {}
          for key,value in component.items():
              if hasattr(value, 'dt'):
                  val = value.dt.isoformat()
              else:
                  val = value.to_ical().decode('utf-8').replace('\\,', ',')
                  comp_obj[key] = val
                  
          data[cal.name][component.name].append(comp_obj)
          
      return data
#+end_src

#+begin_src python
  def read_ics(source):
      """
      Accepts either a bytes object or a file path.
      Returns ICS content as bytes.
      """
      if isinstance(source, (bytes, bytearray)):
          return source
      path = Path(source)
      return path.read_bytes()          
#+end_src

#+begin_src python
  def parse_args():
      """Parse command line arguments."""
      parser = argparse.ArgumentParser(
          description='Convert ICS calendar files to JSON format',
          formatter_class=argparse.RawDescriptionHelpFormatter,
          epilog="""
  Examples:
    # Fetch from URL and save to file
    %(prog)s --url https://example.com/calendar.ics --output calendar.json
    
    # Fetch from URL and print to stdout
    %(prog)s --url https://example.com/calendar.ics
    
    # Convert local file
    %(prog)s --file calendar.ics --output calendar.json
    
    # Convert local file and print to stdout
    %(prog)s --file calendar.ics
    
    # Customize timeout and formatting
    %(prog)s --url https://example.com/calendar.ics --timeout 60 --json-indent 4
          """
      )
      
      # Input source (mutually exclusive)
      source = parser.add_mutually_exclusive_group(required=True)
      source.add_argument(
          '--url',
          help='Fetch ICS file from URL'
      )
      source.add_argument(
          '--file',
          help='Read ICS file from local path'
      )
      
      # Output options
      parser.add_argument(
          '--output', '-o',
          help='Output JSON file path (default: print to stdout)'
      )
      parser.add_argument(
          '--pretty',
          action='store_true',
          help='Pretty-print JSON with indentation'
      )
      
      # Advanced options
      parser.add_argument(
          '--timeout',
          type=int,
          default=DEFAULT_TIMEOUT,
          help=f'Request timeout in seconds (default: {DEFAULT_TIMEOUT})'
      )
      parser.add_argument(
          '--json-indent',
          type=int,
          default=DEFAULT_JSON_INDENT,
          help=f'JSON indentation spaces when using --pretty (default: {DEFAULT_JSON_INDENT})'
      )
      
      return parser.parse_args()
#+end_src

#+begin_src python
  def main():
      """Main function."""
      args = parse_args()
      
      # Get ICS content
      # if args.url:
      #     print(f"Fetching from URL: {args.url}", file=sys.stderr)
      #     ics_content = fetch_from_url(args.url,args.timeout)
      # else:
      #     print(f"Reading from file: {args.file}", file=sys.stderr)
      #     ics_content = read_from_file(args.file)
      if args.url:
          print(f"Fetching from URL: {args.url}", file=sys.stderr)
          ics_content = read_ics(requests.get(args.url, timeout=args.timeout).content)
      else:
          print(f"Reading from file: {args.file}", file=sys.stderr)
          ics_content = read_ics(args.file)
          
      # Convert to dictionary
      try:
          data = ics_to_dict(ics_content)
      except Exception as e:
          print(f"Error: Failed to parse ICS content: {e}", file=sys.stderr)
          sys.exit(1)
          
      # Convert to JSON
      json_indent = args.json_indent if args.pretty else None
      json_output = json.dumps(data, indent=json_indent, ensure_ascii=False)
      
      # Output
      if args.output:
          try:
              output_path = Path(args.output)
              output_path.parent.mkdir(parents=True, exist_ok=True)
              output_path.write_text(json_output, encoding='utf-8')
              print(f"âœ“ Saved to {args.output}", file=sys.stderr)
          except Exception as e:
              print(f"Error: Failed to write output file: {e}", file=sys.stderr)
              sys.exit(1)
      else:
          # Print to stdout
          print(json_output)
          
      return 0
#+end_src

#+begin_src python
  if __name__ == '__main__':
      sys.exit(main())
#+end_src
** init
:PROPERTIES:
:header-args: :tangle "../py/__init__.py"
:END:

#+header: :noweb yes
#+begin_src python
  <<py-license>>
#+end_src

* shell
** header

#+name: shell-shebang
#+begin_src python
  #!/usr/bin/env bash
#+end_src

** ical2json
*** setup

~Ctrl-C Ctrl-C~
#+begin_src sh
  # One time setup for ical2json
  pipenv install flask requests icalendar
#+end_src

#+begin_src sh
  chmod +x ./py/ical2json.py
#+end_src

#+begin_src sh
  chmod +x ./sh/ical2json.example.sh
#+end_src

*** example
:PROPERTIES:
:header-args+: :tangle "../sh/example.ical2json.sh"
:END:

#+header: :noweb yes
#+begin_src shell
  <<shell-shebang>>
#+end_src

#+header: :noweb yes
#+begin_src shell
  <<py-license>>
#+end_src

#+begin_src shell
  # Troubleshooting:
  # - Address already in use Port 5000 is in use by another program
  # `fuser -k 5000/tcp || true`
#+end_src

#+header: :noweb-ref shell-cal-example-common
#+begin_src sh
  set -e
#+end_src

#+header: :noweb-ref shell-cal-example-common
#+begin_src sh
  cd "$(dirname "$0")/.."
#+end_src

#+header: :noweb-ref shell-cal-example-common
#+begin_src shell
  ics_url=$(jq -r '.dummy_ics_url' ./json/config.json)
  # echo "$ics_url"
#+end_src

#+header: :noweb-ref shell-cal-example-common
#+begin_src shell
  cal_json='json/calendar.json'
#+end_src

#+begin_src shell
  port=5000
  url_local="http://127.0.0.1:${port}"
  url_proxy="${url_local}/${ics_url}"
#+end_src

#+begin_src shell
  # Start Flask
  pipenv run python py/ical2json.py &
  flask_pid=$!
  trap "kill $flask_pid 2>/dev/null || true" EXIT
#+end_src

#+begin_src shell
  # Wait for server
  for i in {1..30}; do
      curl -s -o /dev/null "${url_local}/" 2>/dev/null && break
      sleep 0.5
  done
#+end_src

#+begin_src shell
  # Fetch JSON and save
  curl -s "${url_proxy}" > "$cal_json"
  echo "Saved to $cal_json"
#+end_src

** ics2json
*** setup

#+begin_src sh
  chmod +x ./py/ics2json.py
#+end_src

*** example
:PROPERTIES:
:header-args: :tangle "../sh/example.ics2json.sh"
:END:

#+header: :noweb yes
#+begin_src shell
  <<shell-shebang>>
#+end_src

#+header: :noweb yes
#+begin_src shell
  <<py-license>>
#+end_src

#+begin_src shell
  # Root of the project
  SCRIPT_DIR="$(realpath "$(dirname "$0")")"
  PROJECT_ROOT="$(realpath "$SCRIPT_DIR/..")"
#+end_src

#+begin_src shell
  printf 'DEBUG:\n- script_dir=%s\n- project_root=%s\n' "$SCRIPT_DIR" "$PROJECT_ROOT"
#+end_src

#+begin_src shell
  ics_url=$(jq -r '.dummy_ics_url' "$PROJECT_ROOT/json/config.json")
  cal_json="$PROJECT_ROOT/json/calendar.json"
#+end_src

#+begin_src shell
  pipenv run python "$PROJECT_ROOT/py/ics2json.py" --url "$ics_url" --output "$cal_json"
#+end_src

* json
** config
:PROPERTIES:
:header-args: :tangle "../json/config.json"
:END:

#+begin_src json
  {
      "dummy_ics_url": "https://calendar.google.com/calendar/ical/fbca81cd123446a7caa621265f17600826434749f0307a0d2bec578dc41593e5%40group.calendar.google.com/public/basic.ics"
  }
#+end_src
