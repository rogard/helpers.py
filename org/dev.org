# helpers.py

#+begin_src org
  This is a meta file from which are generated source files.
#+end_src

* py
** shebang

#+name: py-shebang
#+begin_src python
  #!/usr/bin/env python
#+end_src

** license

#+name: py-license
#+begin_src python
  # -----------------------------------------------------------------
  # Copyright (C) 2025 Erwann Rogard
  # Source repository: https://github.com/rogard/helpers.py
  #
  # Python code:
  # Released under the GNU General Public License v3.0 or later
  # See https://www.gnu.org/licenses/gpl-3.0.html
  # -----------------------------------------------------------------
#+end_src

** censor
:PROPERTIES:
:header-args: :tangle "../py/censor.py"
:END:

#+header: :noweb yes
#+begin_src python
  <<py-shebang>>
#+end_src

#+header: :noweb yes
#+begin_src python
  <<py-license>>
#+end_src

#+begin_src python
  import os
  import re
  import sys
#+end_src

#+begin_src python
  UNSAFE_INFIX = ".unsafe"
#+end_src

#+begin_src python
  DEFAULT_COMMENT_SYMBOLS = {
      "py": "#",
      "python": "#",
      "js": "//",
      "javascript": "//",
      "ts": "//",
      "cpp": "//",
      "c": "//",
      "h": "//",
      "java": "//",
      "rb": "#",
      "sh": "#",
      "bash": "#",
      "tex": "%",
      "txt": "#",
      "md": "<!--",
  }
#+end_src

#+begin_src python
  def guess_comment_symbol(language: str) -> str:
      """Return the default comment symbol for a given language."""
      return DEFAULT_COMMENT_SYMBOLS.get(language.lower(), "#")
#+end_src

#+begin_src python
  # Default infix for unsafe files
  UNSAFE_INFIX = ".unsafe"
#+end_src

#+begin_src python
  CENSOR_BEGIN_ANCHOR_TEMPLATE = "{comment} <censor>"
  CENSOR_END_ANCHOR_TEMPLATE = "{comment} </censor>"
#+end_src

#+begin_src python
  DEFAULT_COMMENT_SYMBOLS = {
      "py": "#",
      "python": "#",
      "js": "//",
      "javascript": "//",
      "ts": "//",
      "cpp": "//",
      "c": "//",
      "h": "//",
      "java": "//",
      "rb": "#",
      "sh": "#",
      "bash": "#",
      "tex": "%",
      "txt": "#",
      "md": "<!--",
  }
#+end_src

#+begin_src python
  def guess_comment_symbol(language: str) -> str:
      return DEFAULT_COMMENT_SYMBOLS.get(language.lower(), "#")
#+end_src

#+begin_src python
  def infer_output_path(input_path: str, infix: str) -> str:
      """
      Remove the first occurrence of `infix` from the filename.
      Raise ValueError if `infix` is not found.
      """
      base, ext = os.path.splitext(input_path)
      if infix not in base:
          raise ValueError(f"Input file '{input_path}' does not contain the required infix '{infix}'")
      cleaned_base = base.replace(infix, "", 1)
      return cleaned_base + ext
#+end_src

#+begin_src python
  def process_file(*, input_path, output_path=None, language=None,
                   comment_symbol=None, search_begin=None,
                   search_end=None, replace_fn=None, infix=UNSAFE_INFIX):
      """
      Process a file by replacing text between <censor> anchors.
      All parameters are keyword-only.

      output_path:
          - None: auto-infer from input_path by removing `infix`
          - "-": print to stdout
          - sys.stdout: print to stdout
          - string: path to output file
      """
      # Compute output_path if not provided
      if output_path is None:
          output_path = infer_output_path(input_path, infix=infix)

      # Compute language from extension
      if language is None:
          ext = os.path.splitext(input_path)[1].lstrip(".")
          language = ext or "txt"

      # Compute comment_symbol
      if comment_symbol is None:
          comment_symbol = guess_comment_symbol(language)

      # Compute search anchors
      if search_begin is None:
          search_begin = CENSOR_BEGIN_ANCHOR_TEMPLATE.format(comment=comment_symbol)
          
      if search_end is None:
          search_end = CENSOR_END_ANCHOR_TEMPLATE.format(comment=comment_symbol)

      # Default replacement function
      if replace_fn is None:
          replace_fn = lambda: f"{comment_symbol} CENSORED"

      # Build regex pattern (non-greedy)
      pattern = re.compile(
          re.escape(search_begin) + r"(.*?)" + re.escape(search_end),
          flags=re.DOTALL
      )

      # Read input
      with open(input_path, "r", encoding="utf-8") as f:
          text = f.read()

      # Replace censored blocks
      new_text = pattern.sub(lambda m: replace_fn(), text)

      # Write output
      if output_path == "-" or output_path is sys.stdout:
          print(new_text, end="")
          print(f"\n[INFO] Sanitized content printed to stdout.", file=sys.stderr)
      else:
          with open(output_path, "w", encoding="utf-8") as f:
              f.write(new_text)
              print(f"Sanitized file written to: {output_path}")
#+end_src

#+begin_src python
  if __name__ == "__main__":
      import argparse
      import sys

      parser = argparse.ArgumentParser(description="Sanitize a file by replacing <censor> blocks.")
      parser.add_argument("input_path", help="Path to the input file")
      parser.add_argument("-o", "--output_path", help="Output file path (use '-' for stdout)", default=None)
      parser.add_argument("-l", "--language", help="Language for comment symbol inference", default=None)
      parser.add_argument("-c", "--comment_symbol", help="Override comment symbol", default=None)
      parser.add_argument("--search_begin", help="Override <censor> begin anchor", default=None)
      parser.add_argument("--search_end", help="Override <censor> end anchor", default=None)
      parser.add_argument("--infix", help="Infix marking unsafe file", default=UNSAFE_INFIX)

      args = parser.parse_args()

      # call the function
      process_file(
          input_path=args.input_path,
          output_path=args.output_path,
          language=args.language,
          comment_symbol=args.comment_symbol,
          search_begin=args.search_begin,
          search_end=args.search_end,
          infix=args.infix
      )
#+end_src

** ical2json
:PROPERTIES:
:header-args: :tangle "../py/ical2json.py"
:END:

This is a COPY of @philippbosch's [[https://github.com/philippbosch/ical2json/blob/master/LICENSE][script ical2censor]].

#+begin_src python
  #!/usr/bin/env python
  # -*- coding: utf-8 -*-
#+end_src

#+begin_src python
  # Original code (Bosch) as recorded at:
  # https://github.com/rogard/helpers.py, commit 9d1a659
#+end_src

#+begin_src python
  #  Copyright (c) 2011, Philipp Bosch
  #
  #  Permission is hereby granted, free of charge, to any person obtaining a
  #  copy of this software and associated documentation files (the Software),
  #  to deal in the Software without restriction, including
  #  without limitation the rights to use, copy, modify, merge, publish,
  #  distribute, sublicense, and/or sell copies of the Software, and to
  #  permit persons to whom the Software is furnished to do so, subject to
  #  the following conditions:
  #
  #  The above copyright notice and this permission notice shall be included
  #  in all copies or substantial portions of the Software.
  #
  #  THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS
  #  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  #  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  #  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  #  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  #  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  #  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#+end_src

#+begin_src python
  import os

  from flask import Flask, abort, jsonify, request
  from icalendar import Calendar
  import requests

  app = Flask(__name__)
#+end_src

#+begin_src python
  @app.route('/')
  def index():
      return u'Please use like <code>http://<script>document.write(location.host);</script><noscript>ical2json.pb.io</noscript>/http://www.myserver.com/path/to/file.ics</code><br>Source code and instructions at <a href="http://github.com/philippbosch/ical2json">http://github.com/philippbosch/ical2json</a>.'
#+end_src

#+begin_src python
  @app.route('/<path:url>')
  def convert_from_url(url):
      if url == 'favicon.ico':
          abort(404)
      if not url.startswith('http'):
          url = 'http://%s' % url

      try:
          r = requests.get(url)
          r.raise_for_status()
          
          # previous attempt:
          # try:
          #     r = requests.get(url)
          # except:
          #     abort(500)
          # if not r.ok:
          #     abort(r.status_code)
          
          ics = r.content
          cal = Calendar.from_ical(ics)
      except requests.HTTPError as e:
          # Source URL returned an error
          abort(e.response.status_code if 400 <= e.response.status_code < 600 else 500)
      except requests.RequestException:
          abort(502)  # Bad Gateway - couldn't reach source
      except Exception:
          abort(500)  # Internal error parsing ICS

      # build data
      data = {}
      data[cal.name] = dict(cal.items())

      for component in cal.subcomponents:
          if not component.name in data[cal.name]:
              data[cal.name][component.name] = []

          comp_obj = {}
          for item in component.items():
              if hasattr(item[1], 'dt'):
                  val = item[1].dt.isoformat()
              else:
                  val = item[1].to_ical().decode('utf-8').replace('\\,', ',')
                  comp_obj[item[0]] = val

          data[cal.name][component.name].append(comp_obj)

      resp = jsonify(data)
      if 'callback' in request.args:
          resp.data = "%s(%s);" % (request.args['callback'], resp.data)
      return resp
#+end_src

#+begin_src python
  if __name__ == '__main__':
      port = int(os.environ.get('PORT', 5000))
      app.run(host='0.0.0.0', port=port, debug=True)  
#+end_src

#+begin_src python
  if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=False, use_reloader=False)
#+end_src

** init
:PROPERTIES:
:header-args: :tangle "../py/__init__.py"
:END:

#+header: :noweb yes
#+begin_src python
  <<py-license>>
#+end_src

* shell
** constant

#+name: shell-url-ics
#+begin_src shell
  # This is a dummy calendar
  url_ics='https://calendar.google.com/calendar/ical/abe44317faa2cfe48c0ca99b5ede79bca5e401facae66c109e2cc870e0ad8338%40group.calendar.google.com/public/basic.ics'
#+end_src

#+name: shell-cal-json
#+begin_src shell
  cal_json='json/calendar.json'
#+end_src

** ical2json
*** setup

~Ctrl-C Ctrl-C~
#+begin_src sh
  # One time setup for ical2json
  pipenv install flask requests icalendar
#+end_src

#+RESULTS:
| To             | activate        | this      | project's    | virtualenv, | run | pipenv     | shell. |        |      |
| Alternatively, | run             | a         | command      | inside      | the | virtualenv | with   | pipenv | run. |
| Installing     | flask...        |           |              |             |     |            |        |        |      |
| ✔              | Installation    | Succeeded |              |             |     |            |        |        |      |
| Installing     | requests...     |           |              |             |     |            |        |        |      |
| ✔              | Installation    | Succeeded |              |             |     |            |        |        |      |
| Installing     | icalendar...    |           |              |             |     |            |        |        |      |
| ✔              | Installation    | Succeeded |              |             |     |            |        |        |      |
| To             | activate        | this      | project's    | virtualenv, | run | pipenv     | shell. |        |      |
| Alternatively, | run             | a         | command      | inside      | the | virtualenv | with   | pipenv | run. |
| Installing     | dependencies    | from      | Pipfile.lock | (da8323)... |     |            |        |        |      |
| All            | dependencies    | are       | now          | up-to-date! |     |            |        |        |      |
| Building       | requirements... |           |              |             |     |            |        |        |      |
| Resolving      | dependencies... |           |              |             |     |            |        |        |      |
| ✔              | Success!        |           |              |             |     |            |        |        |      |
| To             | activate        | this      | project's    | virtualenv, | run | pipenv     | shell. |        |      |
| Alternatively, | run             | a         | command      | inside      | the | virtualenv | with   | pipenv | run. |
| Installing     | dependencies    | from      | Pipfile.lock | (b85116)... |     |            |        |        |      |
| All            | dependencies    | are       | now          | up-to-date! |     |            |        |        |      |
| Installing     | dependencies    | from      | Pipfile.lock | (b85116)... |     |            |        |        |      |

#+begin_src sh
  chmod +x ./py/ical2json.py
#+end_src

#+begin_src sh
  chmod +x ./sh/ical2json.example.sh
#+end_src

*** example
:PROPERTIES:
:header-args: :tangle "../sh/ical2json.example.sh"
:END:

#+header: :noweb yes
#+begin_src shell
  <<py-license>>
#+end_src

#+begin_src shell
  # Troubleshooting:
  # - Address already in use Port 5000 is in use by another program
  # `fuser -k 5000/tcp || true`
#+end_src

#+begin_src sh
  set -e
#+end_src

#+begin_src sh
  cd "$(dirname "$0")/.."
#+end_src

#+header: :noweb yes
#+begin_src shell
  <<shell-url-ics>>
#+end_src

#+header: :noweb yes
#+begin_src shell
  <<shell-cal-json>>
#+end_src

#+begin_src shell
  #!/bin/bash
  set -e
  cd "$(dirname "$0")/.."
#+end_src

#+begin_src shell
  port=5000
  url_local="http://127.0.0.1:${port}"
  url_proxy="${url_local}/${url_ics}"
#+end_src

#+begin_src shell
  # Start Flask
  pipenv run python py/ical2json.py &
  flask_pid=$!
  trap "kill $flask_pid 2>/dev/null || true" EXIT
#+end_src

#+begin_src shell
  # Wait for server
  for i in {1..30}; do
      curl -s -o /dev/null "${url_local}/" 2>/dev/null && break
      sleep 0.5
  done
#+end_src

#+begin_src shell
  # Fetch JSON and save
  curl -s "${url_proxy}" > "$cal_json"
  echo "Saved to $cal_json"
#+end_src


